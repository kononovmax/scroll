# Документация — алгоритм скролла

Поведение состоит из четырёх состояний — **Drag** (перетаскивание пальцем), **Decel** (инерция после отпускания), **Spring** (пружинный возврат при overscroll) и **Idle** (покой). 

---

## Обозначения (и зачем они нужны)

-   `y` — экранная координата пальца (вниз = `+`).
    _Зачем_: исходная величина из событий ввода.

-   `pos` — логическая позиция контента в пикселях (от верхней границы). Когда `pos` растёт, контент визуально уходит вверх.
    _Зачем_: основная внутренняя переменная, которую двигаем; по ней считают позицию контента и ползунка.

-   `vel` — скорость контента (px/s). Положительная вниз, отрицательная вверх.
    _Зачем_: нужна для инерции (Decel) и для расчёта поведения пружины.

-   `min = 0` и `max = contentHeight - viewportHeight`.
    _Зачем_: границы допустимого скролла; если `max <= 0` — прокрутки нет.

-   `dt` — промежуток времени между кадрами в секундах (используйте реальный таймер).
    _Зачем_: все интеграции должны быть корректны при 60/120 Hz.

-   `clamp(x, a, b) = min(max(x, a), b)`.
    _Зачем_: ограничивает значение в диапазоне.

---

## Параметры (что значат и какие проблемы решают)

-   `MAX_VEL` (рекомендуемое значение: \~9000 px/s)
    _Значение_: потолок стартовой скорости после отпуска пальца.
    _Проблема_: защищает от «выстрелов» при ошибочной или шумной оценке скорости.

-   `STOP_VEL` (рекомендуемое: \~8 px/s)
    _Значение_: порог, ниже которого инерцию считают завершённой.
    _Проблема_: предотвращает вечное микроколебание и переключает в состояние покоя.

-   `HALF_LIFE` (рекомендуемое: \~0.28 s)
    _Значение_: время, за которое скорость инерции уменьшается вдвое.
    _Проблема_: даёт удобную настройку «насколько быстро гаснет» инерция. Из него вычисляется коэффициент затухания:

    ```
    k = ln(2) / HALF_LIFE
    ```

    и экспоненциальное затухание:

    ```
    v(t) = v0 * exp(-k * t)
    ```

-   `RUBBER_C` (рекомендуемое: \~0.55) — сила «резинки» (rubber-band).
    _Значение_: управляет тем, насколько сильно щадится движение при выходе за границы.
    _Проблема_: без этого при overscroll контент уходит «дурацки» далеко; с резинкой пользователь чувствует прогрессивное сопротивление.

-   `SPRING_F` (частота, Hz, \~12) и `SPRING_ZETA` (демпфирование, \~0.75)
    _Значение_: управляют пружинным возвратом: `SPRING_F` — как быстро возвращаемся; `SPRING_ZETA` — будут ли колебания и насколько они затухают.
    _Проблема_: без корректных значений возврат будет либо очень медленным, либо сильно «прыгать».

---

## Состояния (что делают и почему)

-   **Idle** — ничего не двигается: `vel = 0`, `pos` фиксирован.
    _Зачем_: стабильность и экономия CPU.

-   **Drag** — пользователь тянет палец: `pos` следует за движением пальца (с учётом резинки при выходе за границы).
    _Зачем_: основной интерактив; проблема — обеспечить отзывчивость и предсказуемость.

-   **Decel** — инерция после отпускания: `pos` продолжает двигаться по `vel` с затуханием.
    _Зачем_: создаёт ощущение «массы» и плавности. Проблема — корректно угасить скорость и не допустить ухода далеко за границы.

-   **Spring** — когда `pos` вне `[min, max]`: возвращаем к границе пружинной моделью.
    _Зачем_: чтобы вернуть контент в валидную область плавно и с привычным iOS-ощущением.

---

## 1) PointerDown — начало перетаскивания

**Что делать (суть)**: остановить текущую анимацию, сбросить `vel`, начать собирать семплы координат пальца (для оценки скорости).
**Проблема, которую решает**: прерывание текущей автоматической анимации (Decel или Spring) при новом взаимодействии пользователя. Это даёт мгновенный контроль пальцу и устраняет «драконий» переход между автоматикой и ручным управлением.

---

## 2) PointerMove — перемещение пальца

**Что делать (формула)**:

```
dy = y_curr - y_prev
pos += dy
```

**Пояснение**: когда палец двигается вниз (`dy > 0`), `pos` увеличивается — визуально контент уходит вверх.
**Проблема**: нужно, чтобы контент шёл за пальцем точно и отзывчиво. Дополнительная задача — управлять ситуацией, когда пользователь тянет дальше границ — здесь применяется эффект резинки (см. раздел "Rubber-band"). Также важно записывать семплы `(y, t)` в окно последних \~60–100 ms для корректной оценки скорости при отпускании.

---

## 3) Оценка скорости пальца (перед PointerUp)

**Почему это важно**: по нескольким последним семплам (`y_i, t_i`) нужно вычислить `fingerVelocity` — скорость движения пальца. Это влияет на начальную скорость инерции `v0`.

**Надёжная формула (взвешенное среднее скоростей)**:

для i=0..n-2:

```
dt_i = t_{i+1} - t_i
if dt_i <= 0: continue
v_i = (y_{i+1} - y_i) / dt_i    // px / ms
w_i = t_{i+1} - t_0              // вес: более свежие семплы весят больше
sumV += v_i * w_i
sumW += w_i

fingerVelocity_px_per_s = (sumW > 0) ? (sumV / sumW) * 1000 : 0
```

**Проблема**: простой последний `dy/dt` даёт шум и нерепрезентативную скорость; взвешивание уменьшает влияние старых/прыгающих значений. Альтернатива — линейная регрессия `y(t)` по окну 60–100 ms — ещё более стабильна, но чуть сложнее.

---

## 4) PointerUp — решение: Decel или Spring или Idle

**Формула для стартовой скорости**:

```
v0 = clamp(-fingerVelocity, -MAX_VEL, MAX_VEL)
```

(знак минус — потому что направление пальца и направление движения контента противоположны в обозначениях)

**Логика выбора**:

-   Если `pos` вне `[min, max]` → переходим в `Spring` (нужно вернуть в границы).
-   Иначе если `|v0| > STOP_VEL` → `Decel` с начальной `vel = v0`.
-   Иначе → `Idle` (останавливаемся).

**Проблема**: корректно начинать инерцию или возврат; предотвратить «микростопы» и «выстрелы».

---

## 5) Decel — инерция с экспоненциальным затуханием

**Почему экспоненциально**: экспоненциальное затухание даёт естественное ощущение трения — скорость плавно уменьшается в соответствии с `HALF_LIFE`.

**Формула (непрерывная)**:

```
v(t) = v0 * exp(-k * t),  где k = ln(2) / HALF_LIFE
```

**Дискретная (по кадрам, dt в секундах)**:

```
vel *= exp(-k * dt)
pos += vel * dt
```

**Условия перехода**:

-   Если `|vel| < STOP_VEL` → `Idle`.
-   Если `pos` вышла за `[min, max]` → переключаемся в `Spring` (передаём текущее `pos` и `vel`).

**Проблема**: обеспечить плавное замедление и одновременно отслеживать пересечение границ, чтобы не «залипать» за пределами.

---

## 6) Spring — возврат в границы (модель масса–пружина–демпфер)

**Цель**: вернуть `pos` к ближайшей границе (`target = clamp(pos, min, max)`) гладко, без резких скачков и с контролем колебаний.

**Параметры и формулы**:

```
ω = 2π * SPRING_F
K = ω^2
C = 2 * SPRING_ZETA * ω

x = pos - target          // вытяжение пружины (px)
a = -K * x - C * vel      // ускорение (массa=1)
vel += a * dt
pos += vel * dt
```

**Условие завершения**:

```
if |x| < 0.5 px and |vel| < 5 px/s:
    pos = target
    vel = 0
    state = Idle
```

**Проблема**: простое линейное перемещение к границе выглядит неестественно; масса–пружина даёт контролируемый возврат с возможностью демпфирования колебаний. Правильный выбор `SPRING_F` и `SPRING_ZETA` — ключ к приятному ощущению.

---

## Rubber-band (резинка) — понятным языком и формула

**Что это такое (простыми словами)**: когда пользователь тянет контент за границу (например, пытается прокрутить выше верхней границы), экран не должен «пустить» контент свободно — вместо этого движение замедляется и ощущается как растяжение резинки: чем дальше вы тянете, тем сильнее сопротивление, поэтому дополнительное смещение уменьшается.

**Почему это важно**:

-   Даёт интуитивный тактильный отклик.
-   Не позволяет контенту выйти слишком далеко из области.
-   Делает поведение предсказуемым и комфортным.

**Как это реализовать (формула для визуального эффекта)**:

1. Сначала вычисляем логическую позицию и её зажёванную версию:

```
clamped = clamp(pos, min, max)
d = pos - clamped        // расстояние за пределом (px), может быть > 0 или < 0
```

2. Функция резинки (rubberBand):

```
rubberBand(x, dim, c) = (c * x * dim) / (dim + c * x)
```

-   `x` — абсолютное overscroll (|d|), в пикселях.
-   `dim` — размер области (viewportHeight).
-   `c` — коэффициент сильности резинки (`RUBBER_C`, 0..∞; в практике 0.2..0.8).

3. Визуальная позиция для рендера:

```
visualPos = clamped + sign(d) * rubberBand(|d|, viewportHeight, RUBBER_C)
```

**Почему такая формула**:

-   При маленьком `x` результат \~ `c * x` (почти линейно), при больших `x` добавка растёт всё медленнее (асимптотически), значит ощущение «натяжения» усиливается — пользователь чувствует, что его «тянут назад». Это предотвращает уход контента сильно за пределы, но при этом оставляет визуальную обратную связь.

---

## Рендеринг (что именно рисовать)

-   **Контент**: используйте визуальную позицию `visualPos` (с учётом rubber-band) для трансформации слоя контента. Пример:

    ```
    transform: translateY(-visualPos)
    ```

    _Зачем_: чтобы контент следовал за пальцем и показывал overscroll красиво.

-   **Ползунок (thumb)**:

    -   Высота ползунка:

        ```
        thumbHeight = max(minThumbHeight, viewportHeight * (viewportHeight / contentHeight))
        ```

    -   Горизонтальное/вертикальное смещение:

        ```
        maxThumbY = viewportHeight - thumbHeight
        scrollRatio = (max > 0) ? pos / max : 0
        thumbY = maxThumbY * scrollRatio
        ```

    _Зачем_: визуально показывать пользователю относительное положение в документе. Если `max == 0` — прячьте или фиксируйте ползунок.

---

## Краевые случаи и решения (коротко и ясно)

-   **Контент короче чем viewport (`max <= 0`)**
    _Решение_: фиксировать `pos = 0`, прятать/фиксировать thumb. Резинка может работать симметрично сверху и снизу при необходимости.

-   **Высокая частота экрана (120Hz/60Hz)**
    _Проблема_: фиксированные шаги (например, умножение на `1/60`) дают неправильное поведение.
    _Решение_: вычисляйте реальные `dt` и используйте формулы с `dt`.

-   **Шум при оценке скорости**
    _Проблема_: последний `dy/dt` даёт шумные `v0`.
    _Решение_: используйте окно 60–100 ms и взвешенное усреднение или линрегрессию.

-   **Прерывание инерции пальцем**
    _Проблема_: пользователь снова трогает экран во время `Decel`/`Spring`.
    _Решение_: немедленно переходить в `Drag`, обнулять или корректно инициализировать `vel`, иначе ощущение будет «тянущимся».

-   **Nested scroll (вложенные скроллы)**
    _Проблема_: когда внутренний скролл упёрся в границу, дальнейшая часть движения должна идти родителю.
    _Решение_: при `pos` на границе и `sign(dy)` в сторону за границу — передавать «остаток» delta родителю (или не поглощать событие).

-   **Изменение размеров контента на лету**
    _Проблема_: `max` изменился и `pos` оказался вне нового диапазона.
    _Решение_: пересчитать `max`, затем `target = clamp(pos, min, max)`; если `pos` вне, перейти в `Spring`.

-   **Accessibility — Reduce Motion**
    _Проблема_: некоторые пользователи не хотят анимаций.
    _Решение_: уменьшить `RUBBER_C`, уменьшить `SPRING_F`, увеличить `SPRING_ZETA` (≥1) или отключить Decel/Spring вовсе.

---

Если нужно, могу **переписать этот документ ещё проще**, например: сделать его в виде чек-листа для реализации (шаги «что сделать» + одна формула) — скажи, и я подготовлю.
